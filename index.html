<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OsJa â€“ 2-Spieler Match & Attacken wÃ¤hlen</title>

  <!-- Ably JS SDK v1 (enthÃ¤lt Callback- & Promise-API). Wir nutzen die Promise-Variante. -->
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>

  <style>
    :root { --bg:#0b0f14; --panel:#121822; --muted:#93a1b1; --line:#1f2937; --ok:#86efac; --warn:#facc15; --err:#fca5a5; --primary:#2563eb; }
    html,body { margin:0; background:var(--bg); color:#e6eef7; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { max-width: 900px; margin: 32px auto; padding: 0 16px; }
    .card { background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:20px; box-shadow:0 12px 30px rgba(0,0,0,.25); }
    h1 { margin:0 0 6px; font-size:26px; }
    p.sub { margin:0 0 16px; color:var(--muted); }
    .row { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; }
    input, button, select { padding:12px 14px; border-radius:10px; border:1px solid var(--line); background:#0f1420; color:#e6eef7; font-size:16px; }
    button { background:var(--primary); border:0; cursor:pointer; font-weight:600; }
    button.secondary { background:#334155; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; margin-top:16px; }
    .panel { background:#0d121a; border:1px solid var(--line); border-radius:10px; padding:12px; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; max-height:220px; overflow:auto; }
    .badge { display:inline-block; padding:4px 8px; border-radius:10px; font-size:12px; background:#0b3b78; }
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    .attacks { display:grid; grid-template-columns: repeat(auto-fill,minmax(220px,1fr)); gap:8px; margin-top:12px; }
    .attack { display:flex; align-items:center; gap:8px; padding:8px; border:1px solid var(--line); border-radius:10px; background:#0f1420; }
    .small { color:var(--muted); font-size:12px; }
    .pill { padding:2px 8px; border:1px solid var(--line); border-radius:999px; background:#0f1420; font-size:12px; }
    .two-col { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .list { margin:6px 0 0; padding-left:18px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>OsJa â€“ Spiel beitreten & Attacken wÃ¤hlen</h1>
      <p class="sub">Gleicher <b>Code</b> = gleiches Spiel. Wenn zwei drin sind, wÃ¤hlt jede*r <b>4 Attacken</b> und drÃ¼ckt â€žBereitâ€œ.</p>

      <div class="row">
        <input id="name" placeholder="Dein Name (optional)" />
        <input id="code" placeholder="Spielcode, z. B. osja-123" />
        <button id="join">Beitreten</button>
        <button id="leave" class="secondary" disabled>Verlassen</button>
        <span class="badge" id="status">offline</span>
      </div>

      <div class="grid">
        <div class="panel">
          <b>Raum</b>
          <div class="small" id="roomInfo">Kein Raum</div>
          <div class="small">Spieler online: <span id="onlineCount">0</span> / 2</div>
          <div class="small">Du: <span id="meId">â€“</span></div>
          <div class="small">Gegner: <span id="opId">â€“</span></div>
          <div class="small">Status: <span id="readyState">Wartenâ€¦</span></div>
        </div>

        <div class="panel">
          <b>Log</b>
          <div id="log" class="log"></div>
        </div>
      </div>

      <div class="grid">
        <div class="panel">
          <div class="two-col">
            <div><b>Deine Auswahl</b> <span class="pill" id="selCount">0 / 4</span></div>
            <div style="text-align:right">
              <button id="readyBtn" disabled>Bereit senden</button>
            </div>
          </div>
          <div class="row">
            <input id="filter" placeholder="Attacken filternâ€¦" />
            <button id="clearSel" class="secondary" disabled>Auswahl lÃ¶schen</button>
          </div>
          <div id="attacks" class="attacks"></div>
        </div>

        <div class="panel">
          <b>Gegnerische Auswahl</b>
          <ol id="oppList" class="list"></ol>
        </div>
      </div>

      <p class="small">Demo-Hinweis: Frontend-only auf GitHub Pages, Ably-Key ist im Client (fÃ¼r Produktion Token-Auth/Scoped Key).</p>
    </div>
  </div>

  <script>
    const ABLY_KEY = "3wcmYg.8GQUGA:WaFbpDvdQSDdntaxL6mBMg72Om8OcOybipf-Sbs5eRc"; // Demo-Key sichtbar
    const CHANNEL_NS = "osja";

    const ALL_ATTACKS = [
      "Zaubertrick","ZauberkunststÃ¼ck","Prestige","Meister der Magie","Alles oder nichts","Gedankenkontrolle",
      "Feurige Waffen","Hartes Training","Vorbereitung","Wut","MesserwÃ¼rfe","Letzter Wille","Messerstich",
      "Verrat","Schwertschlag","Finale","Heilung","VerfÃ¼hrerisches Angebot","Metallschild","Schneesturm",
      "Schild und Schwert","Schnell","Schneller","Immer vorbereitet","Zweite Chance"
    ];

    const el = (id)=>document.getElementById(id);
    const logEl = el("log"), statusEl = el("status"), roomInfoEl=el("roomInfo");
    const nameEl = el("name"), codeEl = el("code"), joinBtn = el("join"), leaveBtn = el("leave");
    const onlineCountEl=el("onlineCount"), meIdEl=el("meId"), opIdEl=el("opId"), readyStateEl=el("readyState");
    const attacksWrap = el("attacks"), selCountEl = el("selCount"), readyBtn = el("readyBtn");
    const oppListEl = el("oppList"), filterEl = el("filter"), clearSelBtn = el("clearSel");

    let client = null;
    let channel = null;
    let myId = null;
    let mySelection = new Set();
    let oppSelection = [];
    let roomCode = null;
    let iAmReady = false;
    let oppReady = false;
    let presencePoll = null;

    function log(msg, cls="") {
      const d = new Date().toLocaleTimeString();
      const line = document.createElement("div");
      if (cls) line.classList.add(cls);
      line.textContent = `[${d}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function shortId() { return Math.random().toString(36).slice(2, 7); }
    function setConnected(on, code="") {
      statusEl.textContent = on ? `verbunden: ${code}` : "offline";
      joinBtn.disabled = on;
      codeEl.disabled = on;
      nameEl.disabled = on;
      leaveBtn.disabled = !on;
      readyBtn.disabled = !on || mySelection.size !== 4 || iAmReady;
      clearSelBtn.disabled = !on || mySelection.size === 0 || iAmReady;
    }
    function updateSelCounter() {
      selCountEl.textContent = `${mySelection.size} / 4`;
      readyBtn.disabled = !client || mySelection.size !== 4 || iAmReady;
      clearSelBtn.disabled = !client || mySelection.size === 0 || iAmReady;
    }
    function renderAttacks(filter="") {
      attacksWrap.innerHTML = "";
      const f = filter.trim().toLowerCase();
      const list = ALL_ATTACKS.filter(a => a.toLowerCase().includes(f));
      list.forEach(name => {
        const row = document.createElement("label");
        row.className = "attack";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.disabled = iAmReady;
        cb.checked = mySelection.has(name);
        cb.addEventListener("change", () => {
          if (cb.checked) {
            if (mySelection.size >= 4) {
              cb.checked = false;
              log("Du kannst hÃ¶chstens 4 Attacken wÃ¤hlen.", "warn");
              return;
            }
            mySelection.add(name);
          } else {
            mySelection.delete(name);
          }
          updateSelCounter();
        });
        const span = document.createElement("span");
        span.textContent = name;
        row.appendChild(cb);
        row.appendChild(span);
        attacksWrap.appendChild(row);
      });
      updateSelCounter();
    }
    function renderOpponentList() {
      oppListEl.innerHTML = "";
      oppSelection.forEach(n => {
        const li = document.createElement("li");
        li.textContent = n;
        oppListEl.appendChild(li);
      });
    }
    function pickOpponentId(members) {
      const others = members.filter(m => m.clientId !== myId);
      return others[0]?.clientId || null;
    }

    // Liefert PrÃ¤senz-Mitglieder robust â€“ egal ob Promise- oder Callback-/Paginated-Ergebnis
    async function getMembersSafe() {
      try {
        const res = await channel.presence.get();
        if (Array.isArray(res)) return res;          // Realtime Presence: Array<PresenceMessage>
        if (res && Array.isArray(res.items)) return res.items; // PaginatedResult
        return [];
      } catch (e) {
        // Fallback: Callback-API benutzen, falls Promise-API nicht aktiv ist
        return await new Promise((resolve) => {
          channel.presence.get((err, members) => {
            if (err) { log("Presence get Fehler: "+(err.message||err), "err"); resolve([]); return; }
            if (Array.isArray(members)) resolve(members);
            else if (members && Array.isArray(members.items)) resolve(members.items);
            else resolve([]);
          });
        });
      }
    }

    async function refreshPresence() {
      if (!channel) return;
      const members = await getMembersSafe();
      onlineCountEl.textContent = String(members.length);
      const oppId = pickOpponentId(members);
      opIdEl.textContent = oppId || "â€“";

      const oppMember = members.find(m => m.clientId === oppId);
      if (oppMember?.data) {
        oppReady = !!oppMember.data.ready;
        oppSelection = Array.isArray(oppMember.data.selected) ? oppMember.data.selected : [];
      } else {
        oppReady = false;
        oppSelection = [];
      }
      renderOpponentList();

      readyStateEl.textContent = iAmReady && oppReady ? "Beide bereit! ðŸŽ‰" :
                                 iAmReady ? "Du bist bereit. Warte auf Gegnerâ€¦" :
                                 oppReady ? "Gegner ist bereit. WÃ¤hle deine 4!" :
                                            "Warten auf beide Auswahlenâ€¦";
    }

    async function joinRoom() {
      roomCode = (codeEl.value || "").trim().toLowerCase();
      if (!roomCode || roomCode.length < 3) {
        log("Bitte einen Code mit mindestens 3 Zeichen eingeben.", "warn");
        return;
      }
      const baseName = (nameEl.value || "").trim() || "player";
      myId = `${baseName}-${shortId()}`;
      meIdEl.textContent = myId;
      roomInfoEl.textContent = `${CHANNEL_NS}:${roomCode}`;

      // WICHTIG: Promise-Variante der SDK benutzen
      client = new Ably.Realtime.Promise({ key: ABLY_KEY, clientId: myId });

      client.connection.once("connected", async () => {
        log("Mit Ably verbunden.", "ok");
        setConnected(true, roomCode);

        channel = client.channels.get(`${CHANNEL_NS}:${roomCode}`);

        // Presence-Events
        channel.presence.subscribe(["enter","update","leave"], async (msg) => {
          log(`Presence: ${msg.action} (${msg.clientId || "anon"})`);
          await refreshPresence();
        });

        // Attach (Promise-API)
        try {
          await channel.attach();
          log("Kanal attached.", "ok");
        } catch (e) {
          log("Fehler beim Attach: " + (e?.message || e), "err");
          return;
        }

        // Presence betreten (Promise-API)
        try {
          await channel.presence.enter({ ready:false, selected:[] });
          log("Presence enter ok.", "ok");
        } catch (e) {
          log("Presence enter fehlgeschlagen: " + (e?.message || e), "err");
        }

        await refreshPresence();

        // Fallback-Polling
        if (presencePoll) clearInterval(presencePoll);
        presencePoll = setInterval(refreshPresence, 3000);
      });

      client.connection.on((stateChange) => {
        log(`Conn: ${stateChange.previous || "â€“"} â†’ ${stateChange.current}`);
        if (["disconnected","suspended","closed","failed"].includes(stateChange.current)) {
          setConnected(false);
          if (presencePoll) { clearInterval(presencePoll); presencePoll = null; }
        }
      });
    }

    async function leaveRoom() {
      try { if (channel) await channel.presence.leave(); } catch(e){ log("Presence leave Fehler: "+(e?.message||e),"err"); }
      try { if (client) client.connection.close(); } catch(e){ log("Close Fehler: "+(e?.message||e),"err"); }
      if (presencePoll) { clearInterval(presencePoll); presencePoll = null; }
      setConnected(false);
      roomInfoEl.textContent = "Kein Raum";
      onlineCountEl.textContent = "0";
      opIdEl.textContent = "â€“";
      readyStateEl.textContent = "Wartenâ€¦";
      iAmReady = false; oppReady = false;
      mySelection.clear();
      oppSelection = [];
      renderAttacks(filterEl.value);
      renderOpponentList();
      log("Verlassen.");
      client = null; channel = null; myId = null; roomCode = null;
    }

    // UI-Events
    document.getElementById("join").addEventListener("click", joinRoom);
    document.getElementById("leave").addEventListener("click", leaveRoom);
    document.getElementById("filter").addEventListener("input", () => renderAttacks(document.getElementById("filter").value));
    document.getElementById("clearSel").addEventListener("click", () => { mySelection.clear(); renderAttacks(document.getElementById("filter").value); });

    document.getElementById("readyBtn").addEventListener("click", async () => {
      if (!client || !channel) return;
      if (mySelection.size !== 4) { log("WÃ¤hle genau 4 Attacken.", "warn"); return; }
      iAmReady = true;
      const arr = Array.from(mySelection);
      try {
        await channel.presence.update({ ready:true, selected:arr });
        log("Bereit gesendet. Auswahl fixiert.", "ok");
      } catch(e) {
        log("Presence update fehlgeschlagen: " + (e?.message || e), "err");
      }
      document.querySelectorAll(".attack input[type=checkbox]").forEach(cb => cb.disabled = true);
      document.getElementById("readyBtn").disabled = true;
      document.getElementById("clearSel").disabled = true;
      await refreshPresence();
    });

    // Initial
    renderAttacks();

    // Cleanup
    window.addEventListener("beforeunload", () => {
      try { if (channel) channel.presence.leave(); } catch {}
      try { if (client) client.connection.close(); } catch {}
      if (presencePoll) { clearInterval(presencePoll); presencePoll = null; }
    });
  </script>
</body>
</html>
