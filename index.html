<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OsJa – Auswahl (Step Flow, Responsive)</title>
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1420; --panel2:#121a2a; --muted:#93a1b1; --line:#1f2937;
      --ok:#86efac; --warn:#facc15; --err:#fca5a5; --primary:#2563eb; --chip:#0b3b78; --accent:#38bdf8;
      --max:1100px;
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:#e6eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    a{color:var(--accent)}
    .app{min-height:100dvh;display:flex;flex-direction:column}
    /* Topbar */
    .topbar{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,#0b0f14 0%,rgba(11,15,20,.92) 100%);border-bottom:1px solid var(--line)}
    .topwrap{display:flex;gap:12px;align-items:center;justify-content:space-between;max-width:var(--max);margin:0 auto;padding:10px 16px}
    .brand{display:flex;align-items:center;gap:10px;font-weight:700;letter-spacing:.3px}
    .dot{width:10px;height:10px;border-radius:50%;background:var(--primary);box-shadow:0 0 16px rgba(37,99,235,.6)}
    .rightbadges{display:flex;gap:8px;flex-wrap:wrap}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;font-size:12px;background:var(--chip);border:1px solid var(--line)}
    /* Stepper / Nav */
    .stepnav{position:sticky;top:52px;z-index:9;background:linear-gradient(180deg,#0b0f14 0%,rgba(11,15,20,.92) 100%);border-bottom:1px solid var(--line)}
    .steprow{max-width:var(--max);margin:0 auto;display:flex;gap:8px;align-items:center;padding:8px 16px;overflow:auto}
    .step{flex:0 0 auto;padding:8px 12px;border:1px solid var(--line);border-radius:999px;background:#0d121a;font-size:13px;opacity:.6;cursor:pointer;white-space:nowrap}
    .step.active{opacity:1;border-color:var(--primary);box-shadow:0 0 0 2px rgba(37,99,235,.2)}
    .step.done{opacity:.9}
    /* Content screens */
    .content{flex:1;max-width:var(--max);margin:0 auto;padding:16px}
    .screen{display:none;animation:fade .15s ease}
    .screen.active{display:block}
    @keyframes fade{from{opacity:0}to{opacity:1}}
    /* Panels & controls */
    .panel{background:var(--panel2);border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:14px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input,button,select{padding:10px 12px;border-radius:10px;border:1px solid var(--line);background:var(--panel);color:#e6eef7;font-size:14px}
    button{background:var(--primary);border:0;cursor:pointer;font-weight:600}
    button.secondary{background:#334155}
    button.ghost{background:transparent;border:1px dashed var(--line)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .chips{display:flex;gap:6px;flex-wrap:wrap}
    .chip{font-size:11px;padding:3px 7px;border:1px solid var(--line);border-radius:999px;background:#0b3b78}
    .pill{padding:2px 8px;border:1px solid var(--line);border-radius:999px;background:#0f1420;font-size:12px}
    .help{color:var(--muted);font-size:13px}
    /* Cards Grid */
    .filters{display:flex;gap:8px;align-items:center;margin-bottom:10px;flex-wrap:wrap;position:sticky;top:calc(52px + 42px); z-index:8;background:linear-gradient(180deg,#121a2a 0%,rgba(18,26,42,.6) 100%);padding:8px;border:1px solid var(--line);border-radius:10px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px}
    .card{background:#0d121a;border:1px solid var(--line);border-radius:12px;padding:10px;display:flex;gap:10px;align-items:flex-start}
    .card input[type="checkbox"]{margin-top:2px}
    .card .title{font-weight:700;font-size:14px}
    .card .tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:4px}
    .card .desc{color:var(--muted);font-size:12px;margin-top:6px;display:none}
    .card .more{font-size:12px;color:var(--accent);cursor:pointer;margin-top:6px}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    /* Footer actions for mobile */
    .footerbar{position:sticky;bottom:0;z-index:10;background:linear-gradient(0deg,#0b0f14 0%,rgba(11,15,20,.92) 100%);border-top:1px solid var(--line)}
    .footerwrap{max-width:var(--max);margin:0 auto;display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 16px;flex-wrap:wrap}
    /* Responsive tweaks */
    @media (max-width:720px){
      .grid{grid-template-columns:repeat(auto-fill,minmax(170px,1fr))}
      input,button{font-size:13px}
    }
  </style>
</head>
<body>
<div class="app">
  <!-- Topbar -->
  <div class="topbar">
    <div class="topwrap">
      <div class="brand"><span class="dot"></span> OsJa</div>
      <div class="rightbadges">
        <span class="badge" id="status">offline</span>
        <span class="badge">Online: <span id="onlineCount">0</span>/2</span>
        <span class="badge">Du: <span id="meId">–</span></span>
        <span class="badge">Gegner: <span id="opId">–</span></span>
      </div>
    </div>
  </div>

  <!-- Stepper -->
  <div class="stepnav">
    <div class="steprow" id="stepper">
      <div class="step active" data-go="0">1) Lobby</div>
      <div class="step" data-go="1">2) Attacken <span class="pill" id="selCount">0/4</span></div>
      <div class="step" data-go="2" id="stepRangelei">3) Rangeleien <span class="pill" id="rangeleiCount">0/3</span></div>
      <div class="step" data-go="3">4) Review & Ready</div>
      <div class="step" data-go="4">5) Leben bezahlen</div>
    </div>
  </div>

  <!-- Content -->
  <main class="content">
    <!-- Screen 0: Lobby -->
    <section class="screen active" data-step="0">
      <div class="panel">
        <h2>Lobby</h2>
        <div class="row" style="gap:12px">
          <input id="name" placeholder="Name (optional)" />
          <input id="code" placeholder="Code (z. B. osja-123)" />
          <button id="join">Beitreten</button>
          <button id="leave" class="secondary" disabled>Verlassen</button>
          <span class="help">Tritt demselben Code wie dein Gegner bei.</span>
        </div>
        <div class="row" style="margin-top:8px">
          <div class="pill">Raum: <span id="roomInfo">–</span></div>
        </div>
      </div>
      <div class="panel">
        <h3>Status</h3>
        <div id="readyState" class="help">Warten…</div>
      </div>
      <div class="panel">
        <h3>Log</h3>
        <div id="log" class="help" style="max-height:220px;overflow:auto"></div>
      </div>
    </section>

    <!-- Screen 1: Attacken -->
    <section class="screen" data-step="1">
      <div class="panel">
        <div class="row" style="justify-content:space-between">
          <h2>Attacken auswählen</h2>
          <div class="chips">
            <span class="chip" id="slotsInfo" style="display:none">VA: +2 Slots</span>
          </div>
        </div>
        <div class="filters">
          <input id="filter" placeholder="Attacken filtern…" style="flex:1" />
          <label class="row"><input type="checkbox" id="onlyPassiv"/><span>nur Passiv</span></label>
          <label class="row"><input type="checkbox" id="onlyExtra"/><span>nur Extra</span></label>
          <label class="row"><input type="checkbox" id="onlySchnell"/><span>nur Schnell</span></label>
          <button id="clearSel" class="ghost" disabled>Auswahl löschen</button>
        </div>
        <div id="attacks" class="grid"></div>
      </div>
    </section>

    <!-- Screen 2: Rangeleien -->
    <section class="screen" data-step="2">
      <div class="panel" id="rangeleiGate" style="display:none">
        <h2>Rangeleien</h2>
        <div class="help">Du hast <b>Immer vorbereitet</b> gewählt. Wähle genau drei Rangeleien.</div>
        <div class="filters">
          <input id="rangeleiFilter" placeholder="Rangeleien filtern…" style="flex:1" />
        </div>
        <div id="rangeleis" class="grid"></div>
      </div>
      <div class="panel" id="rangeleiHint">
        <h2>Keine Rangeleien nötig</h2>
        <div class="help">Der Schritt wird übersprungen, da <b>Immer vorbereitet</b> nicht ausgewählt ist.</div>
      </div>
    </section>

    <!-- Screen 3: Review & Ready -->
    <section class="screen" data-step="3">
      <div class="panel">
        <h2>Deine Auswahl</h2>
        <div class="row">
          <div class="pill">Attacken: <span id="reviewAttCount">0/4</span></div>
          <div class="pill">Rangeleien: <span id="reviewRanCount">0/3</span></div>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px">
          <div>
            <h3>Attacken</h3>
            <ol id="reviewAtt" class="help"></ol>
          </div>
          <div>
            <h3>Rangeleien</h3>
            <ol id="reviewRan" class="help"></ol>
          </div>
        </div>
      </div>
      <div class="panel">
        <h2>Passiv-Reveal (nach beidseitigem „Bereit“)</h2>
        <div class="row" style="gap:20px">
          <div style="flex:1">
            <div class="help">Deine Passivattacken</div>
            <ol id="myPassives" class="help"></ol>
          </div>
          <div style="flex:1">
            <div class="help">Gegnerische Passivattacken</div>
            <ol id="oppPassives" class="help"></ol>
          </div>
        </div>
      </div>
    </section>

    <!-- Screen 4: Leben bezahlen -->
    <section class="screen" data-step="4">
      <div class="panel" id="payHint">
        <h2>Leben bezahlen</h2>
        <div class="help">
          Dieser Schritt wird freigeschaltet, sobald <b>beide "Bereit"</b> gesendet haben und die <b>Passivattacken offenbart</b> wurden.
        </div>
      </div>

      <div class="panel" id="payGate" style="display:none">
        <h2>Leben bezahlen</h2>
        <div class="row">
          <div class="pill">Startleben: <span id="startLife">500</span></div>
          <div class="pill">Minimum behalten: 200</div>
          <div class="pill">Schrittweite: 5</div>
        </div>

        <div class="row" style="gap:12px;margin-top:8px">
          <input type="range" id="paySlider" min="0" max="300" value="0" step="5" style="flex:1">
          <input type="number" id="payInput" min="0" max="300" value="0" step="5" style="width:110px">
          <div class="pill">Du bezahlst: <span id="myPayView">0</span></div>
          <div class="pill">Du behältst: <span id="myRemainView">500</span></div>
          <button id="sendPayBtn" class="secondary" disabled>Zahlung senden</button>
        </div>

        <div class="row" style="margin-top:8px;gap:16px">
          <div class="pill">Gegner zahlt: <span id="oppPayView">–</span></div>
          <div class="pill">Startspieler: <span id="starterView">–</span></div>
        </div>

        <div class="help" style="margin-top:8px">
          Regel: Beide wählen verdeckt einen Betrag ≥0, in Schritten von <b>5</b>, sodass mind. 200 Leben übrig bleiben.
          Wer mehr bezahlt, beginnt – bei Gleichstand zufällig. Passivattacken werden vor dem Bezahlen offenbart.
        </div>
      </div>
    </section>
  </main>

  <!-- Footer actions -->
  <div class="footerbar">
    <div class="footerwrap">
      <div class="row">
        <button class="secondary" id="prevBtn">← Zurück</button>
        <button id="nextBtn">Weiter →</button>
      </div>
      <div class="row">
        <button id="readyBtn" disabled>Bereit (geheim) senden</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ==== KONFIG ==== */
const ABLY_KEY = "3wcmYg.8GQUGA:WaFbpDvdQSDdntaxL6mBMg72Om8OcOybipf-Sbs5eRc"; // Demo – öffentlich
const CHANNEL_NS = "osja";

/* ==== Daten ==== */
const ATTACKS = [
  {n:"Alles oder nichts", d:"Wähle eine deiner nicht Xmalig- und nicht Superattacken, führe sie aus und entferne sie dann. Am Ende des nächsten gegnerischen Zuges erneut ausführen.", t:["Einmalig"]},
  {n:"Alles wird gut!", d:"Belebe zwei Monster wieder.", t:["Einmalig"]},
  {n:"Bitte extra!", d:"Kontere eine Extra-Attacke.", t:["Dreimalig","Extra","Schnell"]},
  {n:"Feuerkobold", d:"Beschwöre ein 0/50 Monster mit: Bei Beschwörung 50 Schaden an ein Ziel.", t:[]},
  {n:"Feurige Waffen", d:"Erhalte in diesem Zug 10 Wut.", t:["Einmalig","Extra"]},
  {n:"Finale", d:"150 Schaden.", t:["Einmalig"]},
  {n:"Finales Ritual", d:"Verursacht die gesamte Menge an Schaden, die du in deinem eigenen Zug in diesem Spiel erhalten hast.", t:["Einmalig"]},
  {n:"Freund der Tiere", d:"Beschwöre ein 50/50 Monster.", t:[]},
  {n:"Gedankenkontrolle", d:"Gegner verrät seine Attacken. Wähle eine davon und setze sie ein (für ihn zählt der Verbrauch).", t:[]},
  {n:"Geheime Mission", d:"90 Schaden. Nicht konterbar.", t:[]},
  {n:"Gelbe Karte", d:"100 Schaden. Ist dies genau die 2. gespielte gelbe Karte (global), stattdessen 250 Schaden.", t:["Einmalig"]},
  {n:"Geschenk des Lebens", d:"Verleihe allen freundlichen Monstern +50 Leben.", t:[]},
  {n:"Gleichheit", d:"Setze die Leben des Gegners auf deine aktuellen Leben.", t:["Nicht schnell"]},
  {n:"Hartes Training", d:"Erhalte 10 Wut.", t:[]},
  {n:"Heilung", d:"Heile 100 Leben.", t:["Super3"]},
  {n:"Immer vorbereitet", d:"Wähle vor Spielbeginn 3 Rangeleien und füge sie zu deinen Attacken hinzu.", t:["Passiv"]},
  {n:"Karnickel", d:"Beschwöre drei 0/10 Monster.", t:[]},
  {n:"Konter", d:"Kontere eine Attacke.", t:["Schnell","Super3"]},
  {n:"Langsam, aber sicher", d:"10 × (Anzahl deiner erfolgreich ausgeführten Attacken) Schaden.", t:[]},
  {n:"Lebender Baum", d:"Beschwöre ein 0/150 Monster.", t:["Super2"]},
  {n:"Lebender Schild", d:"Wähle ein freundliches Monster. Verleihe ihm Spott.", t:[]},
  {n:"Lebenslehre", d:"Verleihe einem Monster eine deiner nicht Xmalig- und nicht Superattacken.", t:[]},
  {n:"Lehren", d:"Verleihe einem Charakter die Attacke: ‚100 Schaden‘.", t:[]},
  {n:"Letzter Wille", d:"5×20 Schaden.", t:["Einmalig"]},
  {n:"Letzte Chance", d:"Wenn du das nächste Mal tödlichen Schaden bekämst: negiere ihn und heile 50.", t:["Einmalig"]},
  {n:"Meister der Magie", d:"Verursacht 30 × (Anzahl ausgelöster Geheimnisse) Schaden.", t:[]},
  {n:"Metallschild", d:"Gegnerische Attacken machen 10 Schaden weniger.", t:["Passiv"]},
  {n:"Messerstich", d:"20 Schaden.", t:["Extra"]},
  {n:"Messerwürfe", d:"4×20 Schaden.", t:[]},
  {n:"Opfer", d:"Vernichte ein freundliches Monster. Alle befreundeten Charaktere erhalten seine Leben (maximale Extraleben).", t:[]},
  {n:"Prestige", d:"Erhalte alle in diesem Spiel ausgelösten Geheimnisse.", t:["Einmalig"]},
  {n:"Schnell", d:"Verleihe einer deiner Attacken in diesem Zug ‚schnell‘.", t:["Extra","Schnell"]},
  {n:"Schneller", d:"Verleihe einer Attacke ‚schnell‘ und ‚Diese Attacke kann keinem Gegner Schaden machen‘.", t:["Extra","Zweimalig","Schnell"]},
  {n:"Schneesturm", d:"Eigener Zug: Angreifer erleidet 10. Im Gegnerzug erfolgreiche Reaktionen: Gegner erleidet 10.", t:["Passiv"]},
  {n:"Schild und Schwert", d:"Verhindere 50 Schaden. Füge 50 Schaden zu.", t:["Schnell"]},
  {n:"Sicherer Schlag", d:"90 Schaden. Schaden nicht veränderbar.", t:[]},
  {n:"Sichere und geheime Mission", d:"60 Schaden. Nicht konterbar. Schaden nicht veränderbar.", t:["Schnell"]},
  {n:"Schwertschlag", d:"100 Schaden.", t:[]},
  {n:"Seelenschlag", d:"120 Schaden. Du erleidest 50 Selbstschaden.", t:[]},
  {n:"Spiegelschild", d:"Der nächste Gegner-Schaden trifft stattdessen den Gegner.", t:["Einmalig"]},
  {n:"Verführerisches Angebot", d:"Du hast 100 Leben weniger. Du kannst 2 Attacken mehr haben.", t:["Passiv"]},
  {n:"Verrat", d:"80 Schaden.", t:["Schnell"]},
  {n:"Vorbereitung", d:"Deine nächste Schaden-Attacke verursacht +30 Schaden.", t:[]},
  {n:"Wachsames Auge", d:"Gegner verrät seine Attacken; wähle eine, sie ist 2 Züge blockiert.", t:["Einmalig","Extra","Schnell"]},
  {n:"Waffen weg!", d:"Gegner führt alle seine Attacken aus; sie haben keinen Effekt (Xmalig/Super werden verbraucht).", t:["Einmalig","Extra"]},
  {n:"Wand", d:"Beschwöre ein 0/10 Monster mit Spott. Es kann nicht angreifen.", t:["Zweimalig"]},
  {n:"Wut", d:"Deine nächste Schaden-Attacke verursacht +20 Schaden.", t:["Einmalig","Extra"]},
  {n:"Über dem Horizont", d:"Erhalte 120 Leben (erhöht maximale Leben).", t:["Einmalig","Schnell"]},
  {n:"Zauberkunststück", d:"Wähle eines von drei zufälligen Geheimnissen (Nr. 1–7).", t:[]},
  {n:"Zaubertrick", d:"Erhalte ein zufälliges Geheimnis.", t:[]},
  {n:"Zellteilung", d:"Opfere eines deiner Monster. Beschwöre ein Monster mit gleichen Leben und Attacken wie das geopferte Monster am Ende deines übernächsten Zuges zweimal.", t:[]},
  {n:"Zwei Wünsche", d:"Kontere eine Attacke.", t:["Zweimalig","Schnell"]},
  {n:"Zweite Chance", d:"Deine Einmalig-Attacken sind Zweimalig.", t:["Passiv"]},
  {n:"Zyklus des Lebens", d:"Notiere/belebe Monster mit Geboren-Marke gemäß Regel.", t:["Passiv"]}
];
const RANGELEIEN = [
  {n:"Doppelter Spott", d:"Verleihe beliebig vielen Gegnern Spott.", t:["Zweimalig","Extra"]},
  {n:"Einen Schritt voraus", d:"Kontere eine Attacke, die eine deiner Attacken kontert.", t:["Zweimalig","Extra","Schnell"]},
  {n:"Gedankenkontrolle", d:"Gegner setzt die Extra-Attacke ein: ‚Füge dir selbst 60 Schaden zu‘.", t:[]},
  {n:"Geschwindigkeitstraining", d:"Verleihe einer Attacke Schnell.", t:[]},
  {n:"Grüne Karte", d:"In diesem Spiel wurde eine gelbe Karte weniger ausgespielt.", t:["Einmalig","Extra"]},
  {n:"Grüne Wiese", d:"Nicht-eigener-Zug-Attacken machen 20 weniger Schaden.", t:["Passiv"]},
  {n:"Gutes Auge", d:"Übernimm die Kontrolle über zwei zufällige Geheimnisse.", t:["Einmalig"]},
  {n:"Heilung", d:"Heile 80 Leben.", t:["Super3"]},
  {n:"Neu geboren", d:"Setze die Leben eines Gegners auf 500.", t:["Einmalig","Extra"]},
  {n:"Ruhe", d:"Alle Attacken machen ab jetzt 30 weniger Schaden und geben 30 weniger Leben.", t:["Einmalig","Schnell"]},
  {n:"Sandsturm", d:"Füge allen Gegnern 50 Schaden zu.", t:[]},
  {n:"Schuss und Schlag", d:"Wähle x∈[3..7]. Gegner A: x×10, Gegner B: (10−x)×10.", t:[]},
  {n:"Schwertschlag", d:"80 Schaden.", t:[]},
  {n:"Wachsames Auge", d:"Gegner verrät dir seine Attacken.", t:["Einmalig","Extra"]},
  {n:"Wieder normal", d:"Zerstöre eine Passivattacke.", t:["Schnell"]}
];

/* ==== UI refs ==== */
const $ = (id)=>document.getElementById(id);
const logEl=$("log"), statusEl=$("status"), roomInfoEl=$("roomInfo"), readyStateEl=$("readyState");
const nameEl=$("name"), codeEl=$("code"), joinBtn=$("join"), leaveBtn=$("leave");
const onlineCountEl=$("onlineCount"), meIdEl=$("meId"), opIdEl=$("opId");
const attacksWrap=$("attacks"), filterEl=$("filter"), selCountEl=$("selCount"), slotsInfoEl=$("slotsInfo");
const onlyPassivEl=$("onlyPassiv"), onlyExtraEl=$("onlyExtra"), onlySchnellEl=$("onlySchnell");
const readyBtn=$("readyBtn"), clearSelBtn=$("clearSel");
const rangeleisWrap=$("rangeleis"), rangeleiFilterEl=$("rangeleiFilter"), rangeleiCountEl=$("rangeleiCount");
const oppPassivesEl=$("oppPassives"), myPassivesEl=$("myPassives");
const stepper=document.getElementById('stepper');
const reviewAtt=$("reviewAtt"), reviewRan=$("reviewRan"), reviewAttCount=$("reviewAttCount"), reviewRanCount=$("reviewRanCount");
const stepRangeleiEl=$("stepRangelei");
const nextBtn=$("nextBtn"), prevBtn=$("prevBtn");
const rangeleiGate=document.getElementById('rangeleiGate'), rangeleiHint=document.getElementById('rangeleiHint');

// ... deine State-Variablen ...
let switchingToBattle = false;   // ich wechsle jetzt nach battle.html
let oppSwitchingToBattle = false; // Gegner wechselt nach battle.html (Signal empfangen)
let lastOppId = null;
let hadOpponent = false;
let client=null, channel=null; let myId=null, roomCode=null;
let sel = new Set();
let selRangelei = new Set();
let iAmReady=false, oppReady=false;
let oppPassives=[]; let myPassives=[]; let revealed=false;
let currentStep=0;
let myStartLife = 500;
let myPay = 0;
let oppPay = null;
let myRoll = null;
let oppRoll = null;
let starter = null;
let payUiShown = false;

function log(msg, cls=""){ const d=new Date().toLocaleTimeString(); const div=document.createElement('div'); if(cls)div.classList.add(cls); div.textContent=`[${d}] ${msg}`; logEl.appendChild(div); logEl.scrollTop = logEl.scrollHeight; }
const shortId=()=>Math.random().toString(36).slice(2,7);
const collator = new Intl.Collator('de', { sensitivity: 'base' });

function hasTag(a, tag){ return (a.t||[]).includes(tag); }
function isPassiveName(name){ const a=ATTACKS.find(x=>x.n===name); return a && hasTag(a,'Passiv'); }
function allowedSlots(){ return 4 + (sel.has('Verführerisches Angebot') ? 2 : 0); }
function needsRangelei(){ return sel.has('Immer vorbereitet'); }
function hasVA(){ return sel.has('Verführerisches Angebot'); }
function computeStartLife(){ return hasVA() ? 400 : 500; } // VA: -100 Leben, +2 Slots
function maxPay(){ return Math.max(0, computeStartLife() - 200); } // mind. 200 behalten

function updateCounters(){
  selCountEl.textContent = `${sel.size}/${allowedSlots()}`;
  slotsInfoEl.style.display = sel.has('Verführerisches Angebot') ? 'inline-flex' : 'none';
  rangeleiCountEl.textContent = `${selRangelei.size}/3`;
  reviewAttCount.textContent = `${sel.size}/${allowedSlots()}`;
  reviewRanCount.textContent = `${selRangelei.size}/${needsRangelei()?3:0}`;

  // ready-button nur im Review/Ready Step und wenn alles passt
  const okAttacks = sel.size === allowedSlots();
  const okRangelei = needsRangelei() ? selRangelei.size === 3 : true;
  readyBtn.disabled = !(client && !iAmReady && okAttacks && okRangelei && currentStep===3);

  clearSelBtn.disabled = iAmReady || (sel.size===0 && selRangelei.size===0);

  // Step 2 sichtbar/nutzbar?
  if(needsRangelei()){
    stepRangeleiEl.style.display='inline-flex';
    rangeleiGate.style.display='';
    rangeleiHint.style.display='none';
  }else{
    rangeleiCountEl.textContent = `0/3`;
    stepRangeleiEl.style.display='inline-flex';
    rangeleiGate.style.display='none';
    rangeleiHint.style.display='';
    selRangelei.clear();
  }
}

/* ====== NEU: GameState bauen & speichern ====== */
function buildGameState() {
  return {
    roomCode,
    myId,
    oppId: (opIdEl.textContent || '–'),
    selections: {
      attacks: [...sel],
      rangeleis: [...selRangelei]
    },
    passives: {
      me: [...myPassives],
      opp: [...oppPassives]
    },
    life: {
      myStartLife,
      myPay,
      oppPay,
      starter: starter === myId ? 'me' : (starter ? 'opp' : null)
    },
    timestamp: Date.now()
  };
}
function saveGameStateAndGo() {
  const state = buildGameState();
  const key = `osja_game_${roomCode || 'default'}`;
  sessionStorage.setItem(key, JSON.stringify(state));

  // --- NEU: Markiere "ich wechsle" & sag dem Gegner Bescheid
  switchingToBattle = true;
  try {
    channel?.publish('battle_starting', { playerId: myId, room: roomCode, ts: Date.now() });
    // Optional, nice-to-have: Presence-Statusphase updaten (kein Leave!)
    channel?.presence.update({ ready: true, phase: 'battle' }).catch(()=>{});
  } catch {}

  const q = roomCode ? `?room=${encodeURIComponent(roomCode)}` : '';
  window.location.href = `battle.html${q}`;
}

/* ====== Ende NEU ====== */

function renderAttackCard(a){
  const wrap=document.createElement('label'); wrap.className='card';
  const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=sel.has(a.n); cb.disabled=iAmReady;
  cb.addEventListener('change',()=>{
    const wasNeeds = needsRangelei();
    if(cb.checked){
      if(selRangelei.has(a.n)) { cb.checked=false; log('Dieser Name ist bereits als Rangelei ausgewählt.', 'warn'); return; }
      if(sel.size >= allowedSlots()) { cb.checked=false; log('Attacken-Slots voll.', 'warn'); return; }
      sel.add(a.n);
    } else {
      sel.delete(a.n);
    }
    if (a.n === 'Immer vorbereitet' && wasNeeds !== needsRangelei()) {
      if(!needsRangelei()) selRangelei.clear();
      renderRangeleis();
    }
    renderReviewLists();
    updateCounters();
  });
  const box=document.createElement('div');
  const title=document.createElement('div'); title.className='title'; title.textContent=a.n;
  const tags=document.createElement('div'); tags.className='tags'; (a.t||[]).forEach(t=>{ const chip=document.createElement('span'); chip.className='chip'; chip.textContent=t; tags.appendChild(chip); });
  const desc=document.createElement('div'); desc.className='desc'; desc.textContent=a.d||'';
  const more=document.createElement('div'); more.className='more'; more.textContent='Was macht diese Attacke?';
  more.addEventListener('click',()=>{ desc.style.display = (desc.style.display==='block')? 'none':'block'; });
  box.appendChild(title); box.appendChild(tags); box.appendChild(more); box.appendChild(desc);
  wrap.appendChild(cb); wrap.appendChild(box);
  return wrap;
}

function renderAttacks(){
  const f=(filterEl.value||'').trim().toLowerCase();
  attacksWrap.innerHTML='';
  let list = ATTACKS.filter(a=>a.n.toLowerCase().includes(f));
  if(onlyPassivEl.checked) list=list.filter(a=>hasTag(a,'Passiv'));
  if(onlyExtraEl.checked) list=list.filter(a=>hasTag(a,'Extra'));
  if(onlySchnellEl.checked) list=list.filter(a=>hasTag(a,'Schnell'));
  list.sort((a,b)=>collator.compare(a.n,b.n));
  list.forEach(a=>attacksWrap.appendChild(renderAttackCard(a)));
  updateCounters();
}

function renderRangeleis(){
  const f=(rangeleiFilterEl?.value||'').trim().toLowerCase();
  rangeleisWrap.innerHTML='';
  let list = RANGELEIEN.filter(a=>a.n.toLowerCase().includes(f));
  list.sort((a,b)=>collator.compare(a.n,b.n));
  list.forEach(a=>{
    const row=document.createElement('label'); row.className='card';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=selRangelei.has(a.n); cb.disabled=iAmReady || !needsRangelei();
    cb.addEventListener('change',()=>{
      if(!needsRangelei()){ cb.checked=false; log('Rangeleien nur mit "Immer vorbereitet".', 'warn'); return; }
      if(cb.checked){
        if(sel.has(a.n)) { cb.checked=false; log('Dieser Name ist bereits als Attacke ausgewählt.', 'warn'); return; }
        if(selRangelei.size>=3){ cb.checked=false; log('Du kannst genau 3 Rangeleien wählen.', 'warn'); return; }
        selRangelei.add(a.n);
      } else { selRangelei.delete(a.n); }
      renderReviewLists();
      updateCounters();
    });
    const box=document.createElement('div');
    const title=document.createElement('div'); title.className='title'; title.textContent=a.n;
    const tags=document.createElement('div'); tags.className='tags'; (a.t||[]).forEach(t=>{ const chip=document.createElement('span'); chip.className='chip'; chip.textContent=t; tags.appendChild(chip); });
    const desc=document.createElement('div'); desc.className='desc'; desc.textContent=a.d||'';
    const more=document.createElement('div'); more.className='more'; more.textContent='Was macht diese Rangelei?';
    more.addEventListener('click',()=>{ desc.style.display = (desc.style.display==='block')? 'none':'block'; });
    box.appendChild(title); box.appendChild(tags); box.appendChild(more); box.appendChild(desc);
    row.appendChild(cb); row.appendChild(box);
    rangeleisWrap.appendChild(row);
  });
  updateCounters();
}

function listPassivesFromSelection(set){ return [...set].filter(isPassiveName); }

function renderReviewLists(){
  reviewAtt.innerHTML=''; reviewRan.innerHTML='';
  [...sel].sort((a,b)=>collator.compare(a,b)).forEach(n=>{ const li=document.createElement('li'); li.textContent=n; reviewAtt.appendChild(li); });
  [...selRangelei].sort((a,b)=>collator.compare(a,b)).forEach(n=>{ const li=document.createElement('li'); li.textContent=n; reviewRan.appendChild(li); });
}

/* ==== Steps ==== */
const screens=[...document.querySelectorAll('.screen')];
const stepButtons=[...document.querySelectorAll('.step')];

function gotoStep(idx){
  currentStep = Math.max(0, Math.min(idx, 4));

  screens.forEach(s=>s.classList.toggle('active', Number(s.dataset.step)===currentStep));
  stepButtons.forEach((b,i)=>{
    b.classList.toggle('active', i===currentStep);
    b.classList.toggle('done', i<currentStep);
  });

  prevBtn.disabled = currentStep===0;
  nextBtn.textContent = currentStep===4 ? "Fertig" : "Weiter →";

  if (currentStep === 2) renderRangeleis();

  renderReviewLists();
  updateCounters();
  updateBattleStartCta(); // NEU: Button-Zustand im letzten Step prüfen
}

stepper.addEventListener('click', (e)=>{
  const el=e.target.closest('.step'); if(!el) return;
  gotoStep(Number(el.dataset.go||0));
});

prevBtn.addEventListener('click', ()=> gotoStep(currentStep-1));

/* ====== NEU: CTA im Pay-Step ====== */
function updateBattleStartCta() {
  if (currentStep !== 4) return;
  if (starter) {
    nextBtn.textContent = "Kampf beginnen";
    nextBtn.disabled = false;
  } else {
    nextBtn.textContent = "Fertig";
    nextBtn.disabled = true;
  }
}
/* ====== Ende NEU ====== */

nextBtn.addEventListener('click', ()=>{
  if (currentStep < 4) {
    if(currentStep===1 && needsRangelei()){
      gotoStep(2);
    }else if(currentStep===2 && !needsRangelei()){
      gotoStep(3);
    }else{
      gotoStep(Math.min(4, currentStep+1));
    }
    return;
  }

  // Step 4: Start nur, wenn Starter feststeht
  if (!starter) {
    log("Der Starter steht noch nicht fest. Bitte beide Beträge senden/abwarten.", "warn");
    updateBattleStartCta();
    return;
  }

  // Speichern & weiterleiten
  saveGameStateAndGo();
});

/* ==== Ably / Lobby ==== */
let presencePoll=null;

async function refreshPresence(){
  if(!channel) return;
  try{
    const res = await channel.presence.get();
    const members = Array.isArray(res)? res : (res?.items||[]);
    onlineCountEl.textContent = String(members.length);

    const opp = members.find(m=>m.clientId!==myId);
    const oppId = opp?.clientId || null;

    opIdEl.textContent = oppId || '–';

    oppReady = !!(opp && opp.data && opp.data.ready===true);
    readyStateEl.textContent =
      iAmReady && oppReady ? 'Beide bereit (Passiv-Reveal folgt)…'
      : iAmReady ? 'Du bist bereit. Warte auf Gegner…'
      : oppReady ? 'Gegner ist bereit. Wähle deine Auswahl…'
      : 'Warten…';

    if (hadOpponent && !oppId) {
      await resetAfterOppLeave();
      return;
    }
    if (oppId) {
      hadOpponent = true;
      lastOppId = oppId;
    }
    await maybeRevealPassives();
  }catch(e){ log('Presence get Fehler: '+(e?.message||e),'err'); }
}

async function maybeRevealPassives(){
  if(revealed || !channel) return;
  try{
    const res = await channel.presence.get();
    const members = Array.isArray(res)? res : (res?.items||[]);
    const bothReady = members.length===2 && members.every(m=>m.data && m.data.ready===true);
    if(!bothReady) return;
    revealed=true;
    myPassives = listPassivesFromSelection(sel);
    await channel.publish('passives_reveal', { playerId: myId, passives: myPassives });
    renderPassivesLists();
    log('Passivattacken offenbart.', 'ok');
    showPayPanelIfReady();
  }catch(e){ log('Reveal Fehler: '+(e?.message||e),'err'); }
}

function renderPassivesLists(){
  myPassivesEl.innerHTML=''; oppPassivesEl.innerHTML='';
  myPassives.forEach(n=>{ const li=document.createElement('li'); li.textContent=n; myPassivesEl.appendChild(li); });
  oppPassives.forEach(n=>{ const li=document.createElement('li'); li.textContent=n; oppPassivesEl.appendChild(li); });
}

function updatePayViews(){
  const remain = myStartLife - myPay;
  $("myPayView").textContent = String(myPay);
  $("myRemainView").textContent = String(remain);
}

function showPayPanelIfReady(){
  if (!revealed) return;
  if (payUiShown) return;
  payUiShown = true;

  const hint = $("payHint");
  const gate = $("payGate");
  if (hint) hint.style.display = "none";
  if (gate) gate.style.display = "";

  myStartLife = computeStartLife();
  $("startLife").textContent = String(myStartLife);

  const m = maxPay();
  const slider = $("paySlider");
  const num = $("payInput");

  const step = 5;
  const max5 = Math.floor(m / step) * step;
  slider.step = String(step);
  num.step = String(step);
  slider.max = String(max5);
  num.max = String(max5);

  myPay = Math.min(myPay, max5);
  myPay = Math.floor(myPay / step) * step;

  slider.value = String(myPay);
  num.value = String(myPay);

  updatePayViews();
  $("sendPayBtn").disabled = false;

  updateBattleStartCta(); // NEU
}

function tryResolveStarter(){
  if (myRoll == null || oppRoll == null || oppPay == null) return;

  const me = myPay;
  const op = oppPay;
  let who;

  if (me > op) who = myId;
  else if (me < op) who = 'op';
  else {
    if (myRoll > oppRoll) who = myId;
    else if (myRoll < oppRoll) who = 'op';
    else who = (myId < (opIdEl.textContent || '')) ? myId : 'op';
  }

  starter = who;
  const text = (who === myId) ? 'Du' : 'Gegner';
  $("starterView").textContent = text;
  log(`Startspieler: ${text}.`, 'ok');
  updateBattleStartCta(); // NEU
}

function setConnected(on, code=''){
  statusEl.textContent = on ? `verbunden: ${code}` : 'offline';
  joinBtn.disabled=on; codeEl.disabled=on; nameEl.disabled=on; leaveBtn.disabled=!on;
  updateCounters();
}

async function joinRoom(){
  roomCode=(codeEl.value||'').trim().toLowerCase(); if(!roomCode||roomCode.length<3){ log('Bitte Code (>=3) eingeben.','warn'); return; }
  const baseName=(nameEl.value||localStorage.getItem('osja_name')||'player').trim(); myId=`${baseName}-${shortId()}`; meIdEl.textContent=myId; roomInfoEl.textContent=`${CHANNEL_NS}:${roomCode}`;
  localStorage.setItem('osja_name', baseName);
  client = new Ably.Realtime.Promise({ key: ABLY_KEY, clientId: myId });
  client.connection.once('connected', async ()=>{
    log('Mit Ably verbunden.','ok'); setConnected(true, roomCode);
    channel = client.channels.get(`${CHANNEL_NS}:${roomCode}`);
    channel.presence.subscribe(['enter','update','leave'], refreshPresence);
    await channel.attach();
    await channel.presence.enter({ ready:false });
    await refreshPresence();
    if(presencePoll) clearInterval(presencePoll); presencePoll=setInterval(refreshPresence, 3000);

    channel.subscribe('passives_reveal', (msg)=>{
      if(msg?.data?.playerId===myId) return;
      oppPassives = Array.isArray(msg.data.passives)? msg.data.passives : [];
      renderPassivesLists();
      log('Gegnerische Passivattacken eingetroffen.','ok');
      showPayPanelIfReady();
    });

    channel.subscribe('life_pay', (msg)=>{
      if(msg?.data?.playerId === myId) return;
      oppPay  = Number(msg.data.pay)  || 0;
      oppRoll = Number(msg.data.roll) || 0;
      $("oppPayView").textContent = String(oppPay);
      tryResolveStarter();
    });

    channel.subscribe('battle_starting', (msg)=>{
  if (msg?.data?.playerId === myId) return; // meine eigene Nachricht ignorieren
  oppSwitchingToBattle = true;
  log('Gegner wechselt in den Kampf…', 'ok');

  // Wenn bei uns schon alles ready ist (Passiv-Reveal erfolgt + Starter bestimmt),
  // kannst du hier sogar automatisch mitwechseln:
  if (revealed && starter) {
    // nur speichern, nicht erneut publishen (Flag setzt saveGameStateAndGo)
    saveGameStateAndGo();
  }
});


  });
  client.connection.on((s)=>{ if(['closed','failed','suspended','disconnected'].includes(s.current)){ setConnected(false); if(presencePoll){clearInterval(presencePoll); presencePoll=null;} } });
}

async function leaveRoom(){
  try{ if(channel) await channel.presence.leave(); }catch{}
  try{ if(client) client.connection.close(); }catch{}
  if(presencePoll){clearInterval(presencePoll); presencePoll=null;}
  setConnected(false);
  roomInfoEl.textContent='–'; onlineCountEl.textContent='0'; opIdEl.textContent='–'; readyStateEl.textContent='Warten…';
  iAmReady=false; oppReady=false; revealed=false; sel.clear(); selRangelei.clear(); myPassives=[]; oppPassives=[]; renderPassivesLists();
  renderAttacks(); renderRangeleis(); renderReviewLists();

  payUiShown = false;
  myStartLife = 500;
  myPay = 0;
  oppPay = null;
  myRoll = null;
  oppRoll = null;
  starter = null;

  const payHintEl = document.getElementById('payHint');
  const payGateEl = document.getElementById('payGate');
  if (payHintEl) payHintEl.style.display = '';
  if (payGateEl) payGateEl.style.display = 'none';

  const sld = document.getElementById('paySlider');
  const num = document.getElementById('payInput');
  if (sld) { sld.value = "0"; sld.max="300"; sld.step="5"; }
  if (num) { num.value = "0"; num.max="300"; num.step="5"; }
  const setText = (id, v)=>{ const el=document.getElementById(id); if(el) el.textContent=v; };
  setText('myPayView',"0");
  setText('myRemainView',"500");
  setText('oppPayView',"–");
  setText('starterView',"–");

  log('Verlassen.');
  client=null; channel=null; myId=null; roomCode=null;
  gotoStep(0);
}

async function resetAfterOppLeave(){
  try { if (channel) await channel.presence.update({ ready:false }); } catch {}

  log('Gegner hat die Lobby verlassen – alles wird zurückgesetzt.', 'warn');

  iAmReady=false; oppReady=false; revealed=false;
  sel.clear(); selRangelei.clear();
  myPassives=[]; oppPassives=[];
  renderPassivesLists();

  document.querySelectorAll('#attacks input[type=checkbox]').forEach(cb=>cb.disabled=false);
  document.querySelectorAll('#rangeleis input[type=checkbox]').forEach(cb=>cb.disabled=false);
  readyBtn.disabled=true; clearSelBtn.disabled=true;

  filterEl.value=''; rangeleiFilterEl && (rangeleiFilterEl.value='');
  renderAttacks(); renderRangeleis(); renderReviewLists();
  updateCounters();

  payUiShown = false;
  myStartLife = 500;
  myPay = 0;
  oppPay = null;
  myRoll = null;
  oppRoll = null;
  starter = null;

  const payHintEl = document.getElementById('payHint');
  const payGateEl = document.getElementById('payGate');
  if (payHintEl) payHintEl.style.display = '';
  if (payGateEl) payGateEl.style.display = 'none';

  const sld = document.getElementById('paySlider');
  const num = document.getElementById('payInput');
  if (sld) { sld.value="0"; sld.max="300"; }
  if (num) { num.value="0"; num.max="300"; }
  const setText = (id, v)=>{ const el=document.getElementById(id); if(el) el.textContent=v; };
  setText('startLife', "500");
  setText('myPayView',"0");
  setText('myRemainView',"500");
  setText('oppPayView',"–");
  setText('starterView',"–");

  opIdEl.textContent = '–';
  hadOpponent = false;
  lastOppId = null;

  gotoStep(0);
  readyStateEl.textContent = 'Warten…';
}


/* ==== Events ==== */
$("join").addEventListener('click', joinRoom);
$("leave").addEventListener('click', leaveRoom);
filterEl.addEventListener('input', renderAttacks);
onlyPassivEl.addEventListener('change', renderAttacks);
onlyExtraEl.addEventListener('change', renderAttacks);
onlySchnellEl.addEventListener('change', renderAttacks);
$("clearSel").addEventListener('click', ()=>{ sel.clear(); selRangelei.clear(); renderAttacks(); renderRangeleis(); renderReviewLists(); });
rangeleiFilterEl?.addEventListener('input', renderRangeleis);

$("readyBtn").addEventListener('click', async ()=>{
  if(!client||!channel) return;
  const okAttacks = sel.size === allowedSlots();
  const okRangelei = needsRangelei()? selRangelei.size===3 : true;
  if(!(okAttacks && okRangelei)){ log('Bitte vollständig auswählen (Slots/Rangeleien).','warn'); return; }
  iAmReady=true;
  await channel.presence.update({ ready:true });
  document.querySelectorAll('#attacks input[type=checkbox]').forEach(cb=>cb.disabled=true);
  document.querySelectorAll('#rangeleis input[type=checkbox]').forEach(cb=>cb.disabled=true);
  readyBtn.disabled=true; $("clearSel").disabled=true;
  await refreshPresence();
});

// Leben bezahlen – UI (5er Schritte)
$("paySlider")?.addEventListener('input', (e)=>{
  const step = 5;
  let v = Number(e.target.value) || 0;
  v = Math.round(v / step) * step;
  const max5 = Number(e.target.max) || 0;
  if (v > max5) v = max5;
  myPay = v;
  $("payInput").value = String(myPay);
  updatePayViews();
});

$("payInput")?.addEventListener('input', (e)=>{
  const step = 5;
  let v = Number(e.target.value);
  if (isNaN(v) || v < 0) v = 0;
  const maxAttr = Number(e.target.max) || maxPay();
  v = Math.min(v, maxAttr);
  v = Math.round(v / step) * step;
  if (v > maxAttr) v = maxAttr - (maxAttr % step);
  if (v < 0) v = 0;
  myPay = v;
  $("paySlider").value = String(myPay);
  updatePayViews();
});

// Leben bezahlen – senden
$("sendPayBtn")?.addEventListener('click', async ()=>{
  if (!channel || !revealed) { log("Noch nicht bereit für die Zahlung.", "warn"); return; }
  myRoll = Math.floor(Math.random() * 10000);
  try{
    await channel.publish('life_pay', { playerId: myId, pay: myPay, roll: myRoll, startLife: myStartLife });
    $("sendPayBtn").disabled = true;
    log(`Zahlung gesendet: ${myPay} (du behältst ${myStartLife - myPay}).`, 'ok');
    tryResolveStarter();
  }catch(e){
    log('Zahlung senden fehlgeschlagen: ' + (e?.message || e), 'err');
  }
});

/* ==== Initial ==== */
renderAttacks(); renderRangeleis(); renderReviewLists(); updateCounters(); gotoStep(0);

// Cleanup
window.addEventListener('beforeunload', ()=>{
  try {
    if (channel) {
      // WICHTIG: Beim Wechsel in den Kampf NICHT aktiv leaven,
      // sonst triggert das beim Gegner sofort den Reset.
      if (!switchingToBattle) {
        channel.presence.leave().catch(()=>{});
      } else {
        // Optional: Phase setzen (s. oben). Kein Leave!
        channel.presence.update({ ready:true, phase:'battle' }).catch(()=>{});
      }
    }
  } catch {}
  try { if (client) client.connection.close(); } catch {}
});
</script>
</body>
</html>
