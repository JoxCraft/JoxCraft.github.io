<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OsJa – Auswahl (Step 1)</title>
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
  <style>
    :root { --bg:#0b0f14; --panel:#121822; --muted:#93a1b1; --line:#1f2937; --ok:#86efac; --warn:#facc15; --err:#fca5a5; --primary:#2563eb; }
    html,body { margin:0; background:var(--bg); color:#e6eef7; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { max-width: 1000px; margin: 32px auto; padding: 0 16px; }
    .card { background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:20px; box-shadow:0 12px 30px rgba(0,0,0,.25); }
    h1 { margin:0 0 6px; font-size:26px; }
    p.sub { margin:0 0 16px; color:var(--muted); }
    .row { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; }
    input, button, select { padding:12px 14px; border-radius:10px; border:1px solid var(--line); background:#0f1420; color:#e6eef7; font-size:16px; }
    button { background:var(--primary); border:0; cursor:pointer; font-weight:600; }
    button.secondary { background:#334155; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; margin-top:16px; }
    .panel { background:#0d121a; border:1px solid var(--line); border-radius:10px; padding:12px; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; max-height:220px; overflow:auto; }
    .badge { display:inline-block; padding:4px 8px; border-radius:10px; font-size:12px; background:#0b3b78; }
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    .attacks { display:grid; grid-template-columns: repeat(auto-fill,minmax(240px,1fr)); gap:8px; margin-top:12px; }
    .attack { display:flex; align-items:flex-start; gap:8px; padding:8px; border:1px solid var(--line); border-radius:10px; background:#0f1420; }
    .name { font-weight:600; }
    .tags { display:flex; flex-wrap:wrap; gap:6px; margin-top:4px; }
    .tag { font-size:11px; padding:2px 6px; border:1px solid var(--line); border-radius:999px; background:#0b3b78; }
    .small { color:var(--muted); font-size:12px; }
    .pill { padding:2px 8px; border:1px solid var(--line); border-radius:999px; background:#0f1420; font-size:12px; }
    .two-col { display:grid; grid-template-columns: 1fr 1fr; gap:10px; align-items:center; }
    .list { margin:6px 0 0; padding-left:18px; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>OsJa – Spiel beitreten & (geheime) Auswahl</h1>
      <p class="sub">Step 1: Korrekte Auswahl-Logik mit <b>Geheimhaltung</b>, <b>Verführerisches Angebot</b> (+2 Slots) & <b>Rangeleien</b> (nur falls <i>Immer vorbereitet</i> gewählt).</p>

      <div class="row">
        <input id="name" placeholder="Dein Name (optional)" />
        <input id="code" placeholder="Spielcode, z. B. osja-123" />
        <button id="join">Beitreten</button>
        <button id="leave" class="secondary" disabled>Verlassen</button>
        <span class="badge" id="status">offline</span>
      </div>

      <div class="grid">
        <div class="panel">
          <b>Raum</b>
          <div class="small" id="roomInfo">Kein Raum</div>
          <div class="small">Spieler online: <span id="onlineCount">0</span> / 2</div>
          <div class="small">Du: <span id="meId">–</span></div>
          <div class="small">Gegner: <span id="opId">–</span></div>
          <div class="small">Status: <span id="readyState">Warten…</span></div>
        </div>

        <div class="panel">
          <b>Log</b>
          <div id="log" class="log"></div>
        </div>
      </div>

      <div class="grid">
        <div class="panel">
          <div class="two-col">
            <div><b>Deine Attacken</b> <span class="pill" id="selCount">0 / 4</span> <span class="small" id="slotsInfo"></span></div>
            <div style="text-align:right">
              <button id="readyBtn" disabled>Bereit (geheim) senden</button>
            </div>
          </div>
          <div class="row">
            <input id="filter" placeholder="Attacken filtern…" />
            <button id="clearSel" class="secondary" disabled>Auswahl löschen</button>
          </div>
          <div id="attacks" class="attacks"></div>
        </div>

        <div class="panel">
          <b>Rangeleien (nur wenn <i>Immer vorbereitet</i> gewählt)</b>
          <div class="small">Wähle genau <b>3</b> Rangeleien. Sie bleiben weiterhin geheim.</div>
          <div class="two-col" style="margin-top:8px">
            <div><span class="pill" id="rangeleiCount">0 / 3</span></div>
            <div style="text-align:right"><input id="rangeleiFilter" placeholder="Rangeleien filtern…" /></div>
          </div>
          <div id="rangeleis" class="attacks"></div>
        </div>
      </div>

      <div class="grid">
        <div class="panel">
          <b>Gegnerische Passivattacken (offenbart nach beidseitigem Bereit)</b>
          <ol id="oppPassives" class="list"></ol>
        </div>
        <div class="panel">
          <b>Deine (offenbarte) Passivattacken</b>
          <ol id="myPassives" class="list"></ol>
        </div>
      </div>

      <p class="small">Geheimhaltung aktiv: Gegner sieht <u>keine</u> Auswahl, bis beide auf „Bereit“ sind. Danach werden nur <b>Passiv</b>-Attacken offenbart (Regelergänzung #1).</p>
    </div>
  </div>

  <script>
    // === KONFIG ===
    const ABLY_KEY = "3wcmYg.8GQUGA:WaFbpDvdQSDdntaxL6mBMg72Om8OcOybipf-Sbs5eRc"; // Demo – öffentlich
    const CHANNEL_NS = "osja";

    // Attacken (Teilmenge mit Tags; erweiterbar)
    const ATTACKS = [
      {n:"Zaubertrick"},
      {n:"Zauberkunststück"},
      {n:"Prestige"},
      {n:"Meister der Magie"},
      {n:"Alles oder nichts"},
      {n:"Gedankenkontrolle"},
      {n:"Feurige Waffen", t:["Einmalig","Extra"]},
      {n:"Hartes Training"},
      {n:"Vorbereitung"},
      {n:"Wut", t:["Einmalig","Extra"]},
      {n:"Messerwürfe"},
      {n:"Letzter Wille", t:["Einmalig"]},
      {n:"Messerstich", t:["Extra"]},
      {n:"Verrat", t:["Schnell"]},
      {n:"Schwertschlag"},
      {n:"Finale", t:["Einmalig"]},
      {n:"Heilung", t:["Super3"]},
      {n:"Verführerisches Angebot", t:["Passiv"]},
      {n:"Metallschild", t:["Passiv"]},
      {n:"Schneesturm", t:["Passiv"]},
      {n:"Schild und Schwert", t:["Schnell"]},
      {n:"Schnell", t:["Extra","Schnell"]},
      {n:"Schneller", t:["Extra","Zweimalig","Schnell"]},
      {n:"Immer vorbereitet", t:["Passiv"]},
      {n:"Zweite Chance", t:["Passiv"]}
    ];

    // Rangeleien (aus der Legende)
    const RANGELEIEN = [
      {n:"Gutes Auge", t:["Einmalig"]},
      {n:"Einen Schritt voraus", t:["Zweimalig","Extra","Schnell"]},
      {n:"Ruhe", t:["Einmalig","Schnell"]},
      {n:"Schwertschlag"},
      {n:"Heilung", t:["Super3"]},
      {n:"Wachsames Auge", t:["Einmalig","Extra"]},
      {n:"Grüne Wiese", t:["Passiv"]},
      {n:"Schuss und Schlag"},
      {n:"Gedankenkontrolle"},
      {n:"Grüne Karte", t:["Einmalig","Extra"]},
      {n:"Wieder normal", t:["Schnell"]},
      {n:"Sandsturm"},
      {n:"Doppelter Spott", t:["Zweimalig","Extra"]},
      {n:"Geschwindigkeitstraining"},
      {n:"Neu geboren", t:["Einmalig","Extra"]}
    ];

    // ==== UI refs
    const $ = (id)=>document.getElementById(id);
    const logEl=$("log"), statusEl=$("status"), roomInfoEl=$("roomInfo"), readyStateEl=$("readyState");
    const nameEl=$("name"), codeEl=$("code"), joinBtn=$("join"), leaveBtn=$("leave");
    const onlineCountEl=$("onlineCount"), meIdEl=$("meId"), opIdEl=$("opId");
    const attacksWrap=$("attacks"), filterEl=$("filter"), selCountEl=$("selCount"), slotsInfoEl=$("slotsInfo");
    const readyBtn=$("readyBtn"), clearSelBtn=$("clearSel");
    const rangeleisWrap=$("rangeleis"), rangeleiFilterEl=$("rangeleiFilter"), rangeleiCountEl=$("rangeleiCount");
    const oppPassivesEl=$("oppPassives"), myPassivesEl=$("myPassives");

    // ==== State
    let client=null, channel=null; let myId=null, roomCode=null;
    let sel = new Set();            // ausgewählte Attacken (geheim)
    let selRangelei = new Set();    // ausgewählte 3 Rangeleien (geheim)
    let iAmReady=false, oppReady=false;
    let oppPassives=[]; let myPassives=[]; let revealed=false;

    function log(msg, cls=""){ const d=new Date().toLocaleTimeString(); const div=document.createElement('div'); if(cls)div.classList.add(cls); div.textContent=`[${d}] ${msg}`; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight; }
    const shortId=()=>Math.random().toString(36).slice(2,7);

    function hasTag(a, tag){ return (a.t||[]).includes(tag); }
    function isPassiveName(name){ const a=ATTACKS.find(x=>x.n===name); return a && hasTag(a,'Passiv'); }
    function allowedSlots(){ return 4 + (sel.has('Verführerisches Angebot') ? 2 : 0); }
    function needsRangelei(){ return sel.has('Immer vorbereitet'); }

    function updateCounters(){
      selCountEl.textContent = `${sel.size} / ${allowedSlots()}`;
      slotsInfoEl.textContent = sel.has('Verführerisches Angebot') ? ' (VA aktiv: +2 Slots)' : '';
      rangeleiCountEl.textContent = `${selRangelei.size} / 3`;
      // Ready nur, wenn Bedingungen erfüllt
      const okAttacks = sel.size === allowedSlots();
      const okRangelei = needsRangelei() ? selRangelei.size === 3 : true;
      readyBtn.disabled = !client || iAmReady || !(okAttacks && okRangelei);
      clearSelBtn.disabled = !client || iAmReady || (sel.size===0 && selRangelei.size===0);
    }

    function renderList(target, list, selectedSet, onToggle){
      target.innerHTML='';
      list.forEach(a=>{
        const row=document.createElement('label'); row.className='attack';
        const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=selectedSet.has(a.n); cb.disabled=iAmReady;
        cb.addEventListener('change',()=>onToggle(a, cb));
        const box=document.createElement('div');
        const name=document.createElement('div'); name.className='name'; name.textContent=a.n;
        const tags=document.createElement('div'); tags.className='tags'; (a.t||[]).forEach(t=>{ const chip=document.createElement('span'); chip.className='tag'; chip.textContent=t; tags.appendChild(chip); });
        box.appendChild(name); box.appendChild(tags);
        row.appendChild(cb); row.appendChild(box); target.appendChild(row);
      });
    }

    function renderAttacks(){
      const f=(filterEl.value||'').trim().toLowerCase();
      const filtered=ATTACKS.filter(a=>a.n.toLowerCase().includes(f));
      renderList(attacksWrap, filtered, sel, (a, cb)=>{
        if(cb.checked){
          // Duplikate mit Rangeleien verhindern (gleicher Name)
          if(selRangelei.has(a.n)) { cb.checked=false; log('Dieser Name ist bereits als Rangelei ausgewählt.', 'warn'); return; }
          if(sel.size >= allowedSlots()) { cb.checked=false; log('Attacken-Slots voll.', 'warn'); return; }
          sel.add(a.n);
        } else { sel.delete(a.n); if(a.n==='Immer vorbereitet'){ selRangelei.clear(); renderRangeleis(); } }
        renderAttacks(); // neu rendern, weil allowedSlots sich ändern kann (VA)
        updateCounters();
      });
      updateCounters();
    }

    function renderRangeleis(){
      const f=(rangeleiFilterEl.value||'').trim().toLowerCase();
      const filtered=RANGELEIEN.filter(a=>a.n.toLowerCase().includes(f));
      renderList(rangeleisWrap, filtered, selRangelei, (a, cb)=>{
        if(!needsRangelei()){ cb.checked=false; log('Rangeleien nur mit "Immer vorbereitet".', 'warn'); return; }
        if(cb.checked){
          if(sel.has(a.n)) { cb.checked=false; log('Dieser Name ist bereits als Attacke ausgewählt.', 'warn'); return; }
          if(selRangelei.size>=3){ cb.checked=false; log('Du kannst genau 3 Rangeleien wählen.', 'warn'); return; }
          selRangelei.add(a.n);
        } else { selRangelei.delete(a.n); }
        updateCounters();
      });
    }

    function listPassivesFromSelection(set){
      const arr=[...set];
      return arr.filter(n=>isPassiveName(n));
    }

    async function maybeRevealPassives(){
      if(revealed) return;
      // Prüfe beidseitig "ready"
      const members = await channel.presence.get();
      const bothReady = members.length===2 && members.every(m=>m.data && m.data.ready===true);
      if(!bothReady) return;
      revealed=true;
      myPassives = listPassivesFromSelection(sel);
      // veröffentliche NUR Passives
      await channel.publish('passives_reveal', { playerId: myId, passives: myPassives });
      renderPassivesLists();
      log('Passivattacken offenbart.', 'ok');
    }

    function renderPassivesLists(){
      myPassivesEl.innerHTML=''; oppPassivesEl.innerHTML='';
      myPassives.forEach(n=>{ const li=document.createElement('li'); li.textContent=n; myPassivesEl.appendChild(li); });
      oppPassives.forEach(n=>{ const li=document.createElement('li'); li.textContent=n; oppPassivesEl.appendChild(li); });
    }

    function setConnected(on, code=''){
      $("status").textContent = on ? `verbunden: ${code}` : 'offline';
      joinBtn.disabled=on; codeEl.disabled=on; nameEl.disabled=on; leaveBtn.disabled=!on;
      updateCounters();
    }

    // ====== Ably / Lobby
    let presencePoll=null;

    async function refreshPresence(){
      if(!channel) return;
      try{
        const members = await channel.presence.get();
        onlineCountEl.textContent = String(members.length);
        const opp = members.find(m=>m.clientId!==myId);
        opIdEl.textContent = opp?.clientId || '–';
        oppReady = !!(opp && opp.data && opp.data.ready===true);
        readyStateEl.textContent = iAmReady && oppReady ? 'Beide bereit (Passiv-Reveal folgt)…' : iAmReady ? 'Du bist bereit. Warte auf Gegner…' : oppReady ? 'Gegner ist bereit. Wähle deine Auswahl…' : 'Warten…';
        await maybeRevealPassives();
      }catch(e){ log('Presence get Fehler: '+(e?.message||e),'err'); }
    }

    async function joinRoom(){
      roomCode=(codeEl.value||'').trim().toLowerCase(); if(!roomCode||roomCode.length<3){ log('Bitte Code (>=3) eingeben.','warn'); return; }
      const baseName=(nameEl.value||'').trim()||'player'; myId=`${baseName}-${shortId()}`; meIdEl.textContent=myId; roomInfoEl.textContent=`${CHANNEL_NS}:${roomCode}`;

      client = new Ably.Realtime.Promise({ key: ABLY_KEY, clientId: myId });
      client.connection.once('connected', async ()=>{
        log('Mit Ably verbunden.','ok'); setConnected(true, roomCode);
        channel = client.channels.get(`${CHANNEL_NS}:${roomCode}`);
        channel.presence.subscribe(['enter','update','leave'], refreshPresence);
        await channel.attach();
        await channel.presence.enter({ ready:false });
        await refreshPresence();
        if(presencePoll) clearInterval(presencePoll); presencePoll=setInterval(refreshPresence, 3000);
        // Nachrichten: Passiv-Reveal
        channel.subscribe('passives_reveal', (msg)=>{
          if(msg?.data?.playerId===myId) return; // eigene ignorieren
          oppPassives = Array.isArray(msg.data.passives)? msg.data.passives : [];
          renderPassivesLists();
          log('Gegnerische Passivattacken eingetroffen.','ok');
        });
      });
      client.connection.on((s)=>{ if(['closed','failed','suspended','disconnected'].includes(s.current)){ setConnected(false); if(presencePoll){clearInterval(presencePoll);presencePoll=null;} } });
    }

    async function leaveRoom(){
      try{ if(channel) await channel.presence.leave(); }catch{}
      try{ if(client) client.connection.close(); }catch{}
      if(presencePoll){clearInterval(presencePoll); presencePoll=null;}
      setConnected(false);
      roomInfoEl.textContent='Kein Raum'; onlineCountEl.textContent='0'; opIdEl.textContent='–'; readyStateEl.textContent='Warten…';
      iAmReady=false; oppReady=false; revealed=false; sel.clear(); selRangelei.clear(); myPassives=[]; oppPassives=[]; renderPassivesLists();
      renderAttacks(); renderRangeleis();
      log('Verlassen.'); client=null; channel=null; myId=null; roomCode=null;
    }

    // ====== UI Events
    $("join").addEventListener('click', joinRoom);
    $("leave").addEventListener('click', leaveRoom);
    filterEl.addEventListener('input', renderAttacks);
    rangeleiFilterEl.addEventListener('input', renderRangeleis);
    clearSelBtn.addEventListener('click', ()=>{ sel.clear(); selRangelei.clear(); renderAttacks(); renderRangeleis(); });

    readyBtn.addEventListener('click', async ()=>{
      if(!client||!channel) return;
      const okAttacks = sel.size === allowedSlots();
      const okRangelei = needsRangelei()? selRangelei.size===3 : true;
      if(!(okAttacks && okRangelei)){ log('Bitte vollständig auswählen (Slots/Rangeleien).','warn'); return; }
      iAmReady=true;
      // Geheimhaltung: Wir senden NUR ready=true
      await channel.presence.update({ ready:true });
      // UI sperren
      document.querySelectorAll('.attack input[type=checkbox]').forEach(cb=>cb.disabled=true);
      readyBtn.disabled=true; clearSelBtn.disabled=true;
      await refreshPresence();
    });

    // Initial
    renderAttacks(); renderRangeleis(); updateCounters();
    window.addEventListener('beforeunload', ()=>{ try{ if(channel) channel.presence.leave(); }catch{} try{ if(client) client.connection.close(); }catch{} if(presencePoll){clearInterval(presencePoll); presencePoll=null;} });
  </script>
</body>
</html>
